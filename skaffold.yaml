apiVersion: skaffold/v4beta13
kind: Config
metadata:
  name: crossplane-function-go-skaffold
  annotations:
    config.kubernetes.io/local-config: "true"
build:
  artifacts:
  - image: crossplane-function-go-skaffold
    custom:
      buildCommand: ./hack/build.sh ./cmd/fn
      dependencies:
        paths:
        - "**/*.go"
        - hack/build.sh
        - go.mod
        - k8s/**/*.yaml
        - package/**/*.yaml
        - skaffold.yaml
        ignore:
        - examples/**
        - managed/**
        - "**/*_test.go"
  insecureRegistries:
  - localhost:5001
  tagPolicy:
    inputDigest: {}
  local:
    concurrency: 0
    push: true
deploy:
  kubectl:
    hooks:
      after:
      # Wait for the Crossplane function to be healthy.
      - host:
          command: [ "echo", "Waiting for function to be healthy..." ]
      - host:
          command: [ "sh", "-c", "kubectl --context $SKAFFOLD_KUBE_CONTEXT wait --for condition=healthy --timeout 60s function --selector skaffold.dev/run-id=$SKAFFOLD_RUN_ID" ]
manifests:
  rawYaml:
  - k8s/*.yaml
resourceSelector:
  allow:
  - groupKind: Function.pkg.crossplane.io
    image:
    - .spec.package
    labels:
    - .*
profiles:
- name: local-registry
  # Working around our local registry and Crossplane's non-standard container image fetching.
  activation:
  - kubeContext: kind.*
  patches:
  - op: add
    path: /manifests/hooks
    value:
      after:
      - host:
          command: [ "sed", "s/localhost:5001/kind-registry:5000/" ]
          dir: k8s
          withChange: true
- name: tail
  # Tail the log output of the function Pod.
  # Activate with `-ptail` when running `skaffold run`.
  # We can't rely on Skaffold's build-in log tailing, as Skaffold doesn't
  # know about the function Pod that the Crossplane controller creates.
  patches:
  - op: add
    path: /deploy/kubectl/hooks/after/-
    value:
      host:
        command: [ "sh", "-c", "echo 'Tailing function log output, press Ctrl+C to stop...' ; kubectl logs --context $SKAFFOLD_KUBE_CONTEXT --namespace crossplane-system --selector pkg.crossplane.io/function=crossplane-function-go-skaffold --container package-runtime --follow" ]
- name: build
  activation:
  - command: build
  patches:
  - op: add
    path: /build/platforms
    value:
    - linux/amd64
- name: dev
  # Use a different base image when running `skaffold dev`.
  activation:
  - command: dev
  patches:
  - op: replace
    path: /build/artifacts/0/custom/buildCommand
    value: RUNTIME_IMAGE=gcr.io/distroless/base-debian12:debug-nonroot ./hack/build.sh ./cmd/fn
- name: debug
  # Alter the Skaffold config when running `skaffold debug`.
  activation:
  - command: debug
  patches:
  # Use a different base image and install delve in the container image for debugging.
  - op: replace
    path: /build/artifacts/0/custom/buildCommand
    value: DEBUG=true ./hack/build.sh ./cmd/fn
  # Add a Crossplane DeploymentRuntimeConfig to enable debugging in the function pod.
  # We could use `kustomize` here to apply a patch instead of duplicating parts of the Function manifest.
  - op: replace
    path: /manifests/rawYaml
    value:
    - k8s/debug/*.yaml
  # Add port forwarding to the Delve debug port.
  # We can't use Skaffold's built-in port forwarding, because Skaffold doesn't know about the Pod that Crossplane provisions.
  - op: add
    path: /deploy/kubectl/hooks/after/-
    value:
      host:
        command: [ "sh", "-c", "./hack/port-forward-debug.sh" ]
- name: release
  # Build for both linux/amd64 and linux/arm64 for release, instead of auto-detecting the platorm.
  patches:
  - op: add
    path: /build/platforms
    value:
    - linux/amd64
    - linux/arm64
  # Use git tag and commit information for tagging the image, instead of a source code digest.
  - op: replace
    path: /build/tagPolicy
    value:
      gitCommit: {}
  # No hacky local registry overrides required for release builds.
  - op: remove
    path: /build/insecureRegistries
  - op: remove
    path: /manifests/hooks/after
